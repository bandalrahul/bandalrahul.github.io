<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Swift By Rahul</title><description></description><link>bandalrahul.github.io</link><language>en</language><lastBuildDate>Mon, 31 Mar 2025 13:59:34 +0530</lastBuildDate><pubDate>Mon, 31 Mar 2025 13:59:34 +0530</pubDate><ttl>250</ttl><atom:link href="bandalrahul.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">bandalrahul.github.io/posts/PushNotificationSimulator</guid><title>How to send push notifications on the iOS simulator?</title><description>Push notifications are the best way to fascinate the audience towards your iOS app. It’s like an alarm to convey your message to your user. Push notifications in ios are handled and authorized by APNs( Apple Push notification services).</description><link>bandalrahul.github.io/posts/PushNotificationSimulator</link><pubDate>Sun, 22 Dec 2024 17:08:00 +0530</pubDate><content:encoded><![CDATA[<h1>How to send push notifications on the iOS simulator?</h1><div style="text-align:center;">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-9268892677399703"
       data-ad-slot="1234567890"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div><p>Push notifications are the best way to fascinate the audience towards your iOS app. It’s like an alarm to convey your message to your user. Push notifications in ios are handled and authorized by APNs( Apple Push notification services).</p><div style="text-align: center;">
    <img src="bandalrahul.github.io/Images/demo.png" alt="Swift Logo">
</div><p>In any organization, there may be hundreds or thousands of developers and testers, sometimes organizations could not afford to give iOS devices for each and every developer or tester. But iOS push notifications can only be sent on devices. Don’t worry bro, In iOS 13 / Xcode 11.4 Apple introduced some new features which are very beneficial for the user’s and developer’s perspective and sending push notifications on simulators is one of them.</p><p>We will go through each and every step one by one, we need a few primary kinds of stuff like Xcode 11.4 and Catalina OS or more than that version.</p><p>How to do Project setup and take permission from the user to receive the push notifications :</p><ol><li>Create a new project.</li><li>Submit the required data such as project names like ‘PushNotifications‘.</li><li>Import UserNotification framework in Appdelegate class.</li></ol><pre><code class="language-swift">‘import UserNotifications’

4. Copy below code in Appdelegate to take authorization from the user to receive the push notification. 
func registerForSendPushNotifications() {
            UNUserNotificationCenter.current()
                .requestAuthorization(options: [.alert, .sound, .badge]) {(granted, error) in
                    print("Push Notification Permission granted: \(granted)")
            }
    }
</code></pre><ol start="5"><li>Call the same function from didFinishLaunchingWithOptions, which is the first function in Appdelegate.</li></ol><pre><code class="language-swift">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {
        // Override point for customization after application launch.
        registerForSendPushNotifications()
        return true
    }
</code></pre><ol start="6"><li>Run the project on the simulator and just pause your running project. Now take a sip of water, your half of the work is done. Now we just have to collect some data which requires sending push notification on the simulator.</li></ol><p>Let’s collect for more information to get notifications over simulator:</p><h4>Simulators Device Identifier </h4><p>Select Window from the menu -&gt; Devices and simulators -&gt; Here you can see the whole list of physical devices and simulators -&gt; Select Device and copy it. And save somewhere in the Notes/ TextEdit.</p><div style="text-align: center;">
    <img src="bandalrahul.github.io/Images/PushNotificationSimulator/configure.gif" alt="Swift Logo" class="responsive-image">
</div><h4>Get Simulator Identifier: </h4><p>Example : 8E1C327E-4B05-4190-AEA1-0646E73A3A49</p><h4>Bundle Identifier : </h4><p>Select Project -&gt; Tap General Tab -&gt; Copy Bundle Identifier -&gt; Paste somewhere in the Notes/TextEdit</p><div style="text-align: center;">
    <img src="bandalrahul.github.io/Images/PushNotificationSimulator/appdelegate.gif" alt="Swift Logo" class="responsive-image">
</div><p>Get Bundle Identifier Example: ‘com.PushNotifications’</p><h4>.APNs File :  </h4><p>We need a JSON payload. The payload contains custom data which include a basic alert, badge count or sound, you can also add your own key-values. I will give you the demo content of the payload file.</p><p>Note: Payload contents should not more than 4 kb (4096 bytes).</p><pre><code class="language-swift">{
    "aps":{
        "alert":"Test drop",
        "sound":"default",
        "badge":3
    }
}
</code></pre><p>Copy this JSON new file change extension of this file ‘.apns’ and save it.</p><p>Now, here we have everything that needs to send push notification on the simulator. Follow the given steps to send notifications.</p><p>Open terminal.</p><p>Enter into the folder where you saved ‘.apns’ file. Like ‘cd Document’.</p><p>Enter this command.</p><p>xcrun simctl push <Device Identifier> <Bundle Identifier> <.apns file name> 

<h4>Example: </h4>
<b>xcrun simctl push 8E1C327E-4B05-4190-AEA1-0646E73A3A49 com.Pushnotification test.apns.</b>

<p> <i>Result : Notification sent to ‘com.Pushnotification’ </i></p>

<div style="text-align: center;">
    <img src="bandalrahul.github.io/Images/PushNotificationSimulator/terminal.png" alt="Swift Logo" class="responsive-image">
</div>

If you receive this message in the console: “Notification sent to com.PushNotification” Congratulations, You got push notifications on your simulator.

If you face any difficulty during implementation, please comment below or you can email me: blogswithrahul@gmail.com .


<h4>Conclusion: </h4>

Apple did a great job, No need to create development certificates and provisional profiles. No need to depend on API developer. Build push notification functionality and move further. Once everything gets configured, you can move it on production.
</p>]]></content:encoded></item><item><guid isPermaLink="true">bandalrahul.github.io/posts/RsultsInSwift</guid><title>Result In Swift</title><description>At the 2019 WWDC Apple introduced a new UI framework called SwiftUI. From the initial phase of iOS development, we are looking at Xibs and storyboards to build a user interface in ios, macOS and WatchOS app, many more developers were fed-up from developing UI by Storyboard, maybe you are one of them, there are a lot of drawbacks of UIkit over SwiftUI.</description><link>bandalrahul.github.io/posts/RsultsInSwift</link><pubDate>Sun, 22 Dec 2024 17:08:00 +0530</pubDate><content:encoded><![CDATA[<h1>Result In Swift</h1><!-- AdSense Code --><div style="text-align:center;">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-9268892677399703"
       data-ad-slot="1234567890"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div><p>Apple introduced Result standard library into Swift Codebase in swift 5, Result has enum type, Result represents the outcome of any Operation or Functionality, like calling asynchronous API call, API response may be Success or failure, We can use Result to represent the combination of API Success and Fail. Let us see how Result works, this is how Result defined in Swift library</p><pre><code class="language-swift">enum Result&lt;Success, Failure&gt; where Failure: Error {
    case success(Success)
    case failure(Failure)
}
</code></pre><p>Result returns either success or failure with value. Success type is generic means it could be anything Array of model objects like [Employee] more may be NSData, String, Int, but failure should always conform Error Type. Syntax be like</p><pre><code class="language-swift">Result &lt;[Employee]?, Error&gt;
</code></pre><h4>Lets Implement Result Practically </h4><p>We looked around how Results defined in Swift library, Now we will perform Result type implementation by calling asynchronous API.</p><p>Here, I have created one model class, it conforms decodable protocol for the sake of decode response received from web service without parsing it by any particular key from the response. if you didn’t get this don’t worry as we will move on, you will get to know why this model class we have created. Here is the example of the model class.</p><pre><code class="language-swift">struct Employee: Decodable {
    var id: Int?
    var first_name : String?
    var last_name: String?
    var email: String?
    var avatar: String?
}

</code></pre><p>As we have discussed Result represents two combinations of the parameter, which are Success and Failure, Success type could be anything model, string, int but Failure should always conform Error type.</p><p>After calling API outcome may be a failure, which will come in front in the form of Error type, Here we are trying to categorize this error by creating APIErrors enum to segregate which type of failure we faced while calling asynchronous API Call, Error may be Url not found, parsing fails, or it could be data missing Error. we have created this enum for readability and understanding purpose to know the cause of the error, You can ignore this part if you want to move on with only basic Error type.</p><pre><code class="language-swift">enum APIErrors: Error {
    case URLNotFoundError
    case ParsingError
    case DataMissingError
}

</code></pre><p>Now, we are in an important phase, keep your eyes on each line. previously we are handling API outcomes ( success and failure ) by adding two parameters in the completion handler to get response results. for example :</p><pre><code class="language-swift">func getEmployeeData(completionHandler: @escaping ([Employee]?, Error?) -&gt; Void) {
    ...
}

</code></pre><p>Since we were checking previously is error is nil, we were considering the API called is successful. and we were handling responses like [Employee] model array data.</p><p>Now we changed a few things in completion handler callback, we wrapped both parameters in the Result type.</p><pre><code class="language-swift">func getEmployeeData(completionHandler: @escaping(Result &lt;[Employee]?, APIErrors&gt;) -&gt; Void ) {
}
</code></pre><p>So Results can send either success or failure to completion handler. if the response will have a successful outcome, Result in returns with any data and if the response will have failure outcome Result in returns with Error type.</p><h4>Result returns success :</h4><pre><code class="language-swift">let employeeObjects = try JSONDecoder.init().decode([Employee].self, from: jsonData)
completionHandler(.success(employeeObjects))
</code></pre><h4>Result returns failure :</h4><pre><code class="language-swift">completionHandler(.failure(.ParsingError))
</code></pre><p>I have created one demo function for the asynchronous API call. I am calling free open-source API and getting employee data, we have already created a model class for handling response. here I conveyed how Result type is responding on API outcome, Outcome may be success or failure, we are returning an Array of Employee objects on success and APIError enum error type on failure. Please look carefully at this bunch of code. I tried my best to convey Result type functioning.</p><pre><code class="language-swift">func getEmployeeData(completionHandler: @escaping(Result &lt;[Employee]?, APIErrors&gt;) -&gt; Void ) {
        let urlString = "https://reqres.in/api/users?"
        guard let url = URL(string: urlString) else {
            print("Invalid url")
            return
        }
        URLSession.shared.dataTask(with: url) { (responseData, responseInfo, error) in
            if error == nil {
                do {
                    let jsonResponse = try JSONSerialization.jsonObject(with: responseData!, options: .mutableContainers)
                    if let responseArray = jsonResponse as? [String:Any] {
                        if let dataArray = responseArray["data"] as? [[String:Any]] {
                            do {
                                let jsonData = try JSONSerialization.data(withJSONObject: dataArray, options: .fragmentsAllowed)
                                let employeeObjects = try JSONDecoder.init().decode([Employee].self, from: jsonData)
                                completionHandler(.success(employeeObjects))
                            } catch  {
                                completionHandler(.failure(.ParsingError))
                            }
                        }
                    }
                } catch {
                    completionHandler(.failure(.DataMissingError))
                }
            } else {
                completionHandler(.failure(.URLNotFoundError))
            }
        }.resume()
    }
</code></pre><p>Now we almost have done everything, implement completion handler wherever you want, Switch Result into .success and .failure block, you will also get success parameter you sent from function itself, as success will return Array of employee objects and failure will return Error type.</p><pre><code class="language-swift">var emps = [Employee]()
    init() {
        getEmployeeData { (result) in
            switch result {
            case  .success(let employees):
                self.emps = employees!
                break
            case  .failure(let error):
                print(error.localizedDescription)
                break
            }
        }
    }

</code></pre><p>I have tried all this code and then added on the blog post, if somebody is not understood anything, please write me an email, I will reply on the same, and If you face anything went wrong in code or explanation please let me know.</p><p>email: blogswithrahul@gmail.com</p><h4>Conclusion :</h4><p>A feature like a Result eliminated lots of uncertainty in the code, Result can be used for handling outcome and states of any logical functionality and critical operations.</p>]]></content:encoded></item><item><guid isPermaLink="true">bandalrahul.github.io/posts/SwiftUIvsUIkit</guid><title>SwiftUI vs UIKit</title><description>At the 2019 WWDC Apple introduced a new UI framework called SwiftUI. From the initial phase of iOS development, we are looking at Xibs and storyboards to build a user interface in ios, macOS and WatchOS app, many more developers were fed-up from developing UI by Storyboard, maybe you are one of them, there are a lot of drawbacks of UIkit over SwiftUI.</description><link>bandalrahul.github.io/posts/SwiftUIvsUIkit</link><pubDate>Sun, 22 Dec 2024 17:08:00 +0530</pubDate><content:encoded><![CDATA[<h1>SwiftUI vs UIKit</h1><div style="text-align:center;">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-9268892677399703"
       data-ad-slot="1234567890"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div><p>At the 2019 WWDC Apple introduced a new UI framework called SwiftUI. From the initial phase of iOS development, we are looking at Xibs and storyboards to build a user interface in ios, macOS and WatchOS app, many more developers were fed-up from developing UI by Storyboard, maybe you are one of them, there are a lot of drawbacks of UIkit over SwiftUI.</p><p>Yeah…. but the SwiftUI also has one major drawback, Apps created in SwiftUI only support iOS 13 and the next version, and SwiftUI don’t allow us to debug hierarchy of views. For now, SwiftUI requires the following pieces of stuff: Xcode 11.4 macOS Catalina to start building apps in SwiftUI.</p><p>It starts and end with view:</p><p>Whole SwiftUI framework is completely looping in view, no more UITableView, UIcollectionView, UIView, UICollectionViewCell, UITableViewCell classes in SwiftUI framework.</p><p>The given example SwiftUI uses Struct to initialize and define through the View protocol. Some properties return View. As Swift UI uses DSL like syntax, the return is omitted from the Struct body.</p><pre><code class="language-swift">import SwiftUI

struct ContentView: View {
    var body: some View {
        Text("Welcome to Swift By Rahul")
    }
}
</code></pre><pre><code class="language-swift">struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre><h4>Sync Design and code  (Declarative Programming): </h4><p>From the launch day of Xcode we are using xibs, storyboards and programmatically UI for developing UI content such as Static &amp; dynamic content, Animation, Graphics, etc. When your user interface is created in code. You can see dynamic previews of this code on-canvas preview. You also have a choice, you can code user interface by yourself or you can use canvas editor(drag and drop UI building tool) to code on behalf.</p><h4>Benefits of declarative programming : </h4><p>Easy to write. Fast. Adaptive (Does Not need recompilation for the preview of the coded User interface) Important Note: Canvas editor UI content reflects in code at the movement, but in UIKit changes done in storyboard or xib are not visualized in UIViewcontroller class.</p><h4>Adopt existing UIKit app with swiftUI:  </h4><p>Yes UIKit and SwiftUI framework can communicate with each other, SwiftUI designed very perfectly to deal with existing frameworks, the UIHostingViewController class is becoming a mediator here. It integrates SwiftUI view with UIKIt ViewController, honestly in genuine SwiftUI App use UIHostingViewController for specifying root view controller to UIWindow.</p><h4>SwiftUI is Reactive :  </h4><p>Traditional iOS development doesn’t support any bindable mechanism in pure swift, that’s why React Swift and React cocoa came into the picture, in SwiftUI Apple achieved some mechanism by state management and binding, though variables and property can bind with the user interface. SwiftUI supports By default MVVM architecture. A combine framework allows us to perform event-oriented operations. Omitted to create and to implement observer and delegate communication patterns by the reactive mechanism.</p><p>Protocols, Classes, and properties like @publisher, @publishers, @anyPublisher, @published, @cancellable and @subscriber are designed to achieve reactive goals in SwiftUI.</p><pre><code class="language-swift">import SwiftUI

struct ContentView: View {
    @State var name = ""
    var body: some View {
        NavigationView {
            VStack {
                TextField("Swift By Rahul", text: $name).padding(12)
                Text(name).padding(12)
            }
        }.background(Color.white)
    }
}
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</code></pre><p>As you can see the variable name is stated by @State property, and the name variable is bound with TextField, so whenever any action performed with TextField, the string value of TextField will eventually store in the name variable.</p><p>Some small benefits of SwiftUI:</p><p>The compilation time of storyboard and xib is far more than SwiftUI. So its quickly compiling and running on the simulator.</p><p>No headache of xib xml file conflicts while merging multiple code commits</p><p>Canvas preview is awesome, needs not to compile the whole project to see UI preview.</p><p>No headache of Constraints, AutoLayout like storyboard.</p><p>App created for iOS can use for MacOS as well. Hardware platform portability is a very crucial feature provided in SwiftUI.</p><p>IBOutlets and UI properties need not to be handle in ViewController class.</p><p>No delegates and datasource methods for UI Components.</p><h4>Conclusion:  </h4><p>SwiftUI is a newborn programming language, its very adaptive to learn but as SwiftUI framework is not working with previous iOS versions like iOS versions less than iOS 13. Start a new project in swift UI, for now, it’s very risky. Because it will not cover 100% audience due to platform compatibility. Yes But SwiftUI is the future of iOS.</p><p>Keep learning…..</p>]]></content:encoded></item><item><guid isPermaLink="true">bandalrahul.github.io/posts/iOSvsAndroid</guid><title>Why the iPhone is more secure than Android?</title><description>Two major operating systems are widely used for mobile phones, iOS, and Android. Android is owned by Google and iOS is owned by Apple, here we will discuss how iOS is more secure than the Android operating system.</description><link>bandalrahul.github.io/posts/iOSvsAndroid</link><pubDate>Sun, 22 Dec 2024 17:08:00 +0530</pubDate><content:encoded><![CDATA[<h1>Why the iPhone is more secure than Android?</h1><div style="text-align:center;">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-9268892677399703"
       data-ad-slot="1234567890"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div><p>Android is an open-source operating system, means Google provides a platform development kit to hardware manufacturers like MI, One plus, and Samsung. Here google is creating software parts of the mobile device and the hardware part is manufactured by other companies, Due to miscommunication between hardware and software developers, version compatibility is the major drawback find in android devices.</p><p>iOS is not an open-source operating system, here Hardware and Software both are developed by Apple, and devices are sold by Apple itself. Durability and usability of Apple iPhones are more than android devices, Because of new iOS versions release after testing new and old devices.</p><p>Example: before the release of iOS 13, Apple tests iOS 13 operating system is properly working on iPhone 7,8,8plus, those phones released with old iOS versions like iOS 10, iOS 11, etc.</p><h4>iCloud : </h4><p>iCloud is a standard technology, using more for backup, where Apple stores all your things, like data including:</p><p>Images</p><p>Videos</p><p>Documents</p><p>Contacts</p><p>Calendar Data</p><p>Notes</p><p>Remainder</p><p>Siri Shortcuts</p><p>Voice Memos</p><p>Emails</p><p>And credentials like :</p><p>Siri information</p><p>Wifi Passwords</p><p>Apple card transactions</p><p>Health App data</p><p>Screen time</p><p>Safari history</p><p>Keyboard frequently used vocabulary</p><p>I will not deep dive technically, how iCloud is better than google cloud and google drive, but yes, iCloud provides end to end encryption, means your data will read-only by sender and receiver, Apple itself can't read your data, Apple is very attentive about Security, Privacy, Authentication,</p><p>If you are using iPhone and logged in iCloud, your photos, documents, videos, credentials are more secure than any android phone and another operating system phone.</p><h4>Messages:</h4><p>Android allows the app developer to ask permission from the user to fetch and read messages, let me give you an example: if you ever used True-caller application. True-caller asked you to allow permission to read messages, contacts and other stuff. If you allow them to read the message they are accessing the message and storing it in their database server. Your message contains personal chat, Bank transaction notifications, Subscription notifications, Portal password, and credentials, or data may be in any form.</p><p>App service like True-caller may leak your data and threaten you. else they are selling your data to other organizations like advertising agencies to collect surveys indirectly from you, like which bank is preferred by users, which subscription users are purchasing? in which things users are in favor?, previously apple was not allowed to read OTP in iOS app, But due to trendy app usability features iOS providing the feature to read OTP by adding new property in UITextfiled components like.<br> textField.textContentType = .oneTimeCode<br> textField.keyboardType = .numberPad</p><h4>Location:</h4><p>Location is a crucial topic with respect to security and privacy. We all are using maps, In Android, we are using google map and in iOS Apple itself using their own, Apple developed a map with partners tomtom and other geodata service provider.</p><p>Android users might be thinking of how Google got to know right now which hotel I am visiting and eventually asking reviews for the same hotel. Places Review notifications look like.</p><p>Means, you are sharing your location with google via your android device, Apple doing the same as accessing user locations like Android, but listen carefully, Apple phones sharing user location with their servers only once in a day, but Android sharing users location at every 4 minutes.</p><p>Google uses user location information for many purposes like advertising, google place recommendation, surveying data for the sake of marketing. Google utilizes your location data to improve its own business. iPhone is very safe to maintain your location privacy.</p><h4>APK (Android Application Package):</h4><p>APK is a package file of an Android Application, It can be shared from one device to another device and install it, It means Android allows to install apps without downloading from play store.</p><p>The major drawback of this, developers can develop buggy and virus contained applications and spread it in the community via APK file. instead of that iPhone won't allow the user to install apps from other resources except for App Store.</p><p>To add an iOS app on App Store apple has strict rules and guidelines than Android, Apple reviewing the application submitted by the developer for 4 to 5 days if anything is not matching and not fitting in their criteria, Apple rejects the application, otherwise, they approve the application and open to use this application for end-user.</p><h4>Conclusion: </h4><p>iPhones are far better than Android devices with respect to security, privacy, and other policies. If you want to secure your data, credentials and other kinds of stuff, iOS better choice for you.</p>]]></content:encoded></item></channel></rss>